<system>
  log_level info
</system>

# receive events over http
# these logs are coming from our node app containers in other namespaces
<source>
  @type http
  port 8080
  bind 0.0.0.0
  body_size_limit 32m
  keepalive_timeout 10s
  <parse>
    @type json
  </parse>
  #add_http_headers true

  ### TLS security disabled
  # <security>
  #   self_hostname fluentd
  #   shared_key fluentd
  # </security>
  # <transport tls>
  #   version                TLSv1_2
  #   ca_path                /fluentd/etc/ssl/ca.crt.pem
  #   cert_path              /fluentd/etc/ssl/server.crt.pem
  #   private_key_path       /fluentd/etc/ssl/server.key.pem
  #   #private_key_passphrase "#{ENV["TLS_PRIVATE_KEY_PASSPHRASE"]}"
  #   #client_cert_auth       true
  # </transport>

</source>

# Recieve events from 24224/tcp
# this is the preferred method for sending logs between fluent-bit and fluent-d peers
# not currently working accross multiple namespaces
#<source>
#  @type forward
#  port 24224
#  bind 0.0.0.0
#</source>


### Process Error logs
# filter logs tagged with 'app' to include only code 5** errors
# and rewrite tag to app.error
<match app>
  @type rewrite_tag_filter
  capitalize_regex_backreference yes
  <rule>
    key     code
    # filter for 5** HTTP response codes
    pattern ^5\d\d$
    tag     ${tag}.error
  </rule>

  <rule>
    key     log
    # filter logs containing string 'EHOSTUNREACH'. for example: 'ERR! Error: connect EHOSTUNREACH 127.0.0.1:6379'
    pattern EHOSTUNREACH
    tag     ${tag}.error
  </rule>

</match>

# reformat *.error logs into a Discord post
# content ${record["product"]} - HTTP response status code ${record["code"]}, hostname: ${record["hostname"]}, namespace: ${record["namespace"]}, agent: ${record["agent"]}, method: ${record["method"]}, path: ${record["path"]}, log: ${record["log"]}
<filter app.error>

  @type record_transformer
  enable_ruby true
  auto_typecast true
  <record>
    username ${record["product"].upcase} (${record["namespace"]}) Alert
    content ```json\n${record.to_json}\n```
  </record>

</filter>

## output errors to Discord AND stdout
<match app.error>
  # You need to use the 'copy' output plugin to output the same log to multiple sources
  @type copy
  <store>
    # output using out_http plugin
    @type http

    # Discord webhook
    endpoint https://discordapp.com/api/webhooks/abc/def

    open_timeout 2
    json_array false
    content_type application/json
    headers {"Content-Type":"application/json"}
    <format>
      @type json
    </format>
    <buffer>
      flush_interval 2s
    </buffer>
  </store>

  # send to stdout as well
  <store>
    @type stdout
  </store>
</match>

### output all other logs to standard out
<match **>
  @type stdout
</match>